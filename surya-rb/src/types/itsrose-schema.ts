/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/me": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** @description Get the account details */
		get: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description The API key used for authentication. This is a secret and should be kept private. */
								apikey: string;
								subscription: {
									/** @description Whether the subscription is active or not */
									active: boolean;
									/**
									 * Format: date-time
									 * @description The expiry date of the current subscription plan.
									 */
									expiry: string | null;
									/** @description The name of the subscription plan. This is a string and can be used to identify the plan. */
									product: string;
								};
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/status": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** @description Check if the service is up and running */
		get: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description Indicates if the service is operational */
								ok: boolean;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/ai_song/get_task": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get task
		 * @description Retrieve detailed information about a music generation task.
		 */
		get: {
			parameters: {
				query: {
					/** @description The comma-separated list of task IDs to retrieve */
					task_id: string;
				};
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							/** @description List of task objects. */
							result?: components["schemas"]["AISongTaskOutput"][];
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/ai_song/submit_task": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Submit task
		 * @description Generate music with or without lyrics using AI models.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			/** @description The request body for submitting a new task */
			requestBody: {
				content: {
					"application/json":
						| components["schemas"]["AISongSubmitTaskAuto"]
						| components["schemas"]["AISongSubmitTaskCustom"];
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							/** @description The response of the submit task request */
							result?: {
								/** @description The list of submitted task ids */
								task_ids: string[];
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/elevenlabs/clone_voice": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Clone Voice
		 * @description Clone a voice into text-to-speech model.
		 *
		 *     - `enterprise` plan can clone up to 100 voices per day.
		 *     - `team` plan can clone 50 voices per day.
		 *     - `pro` plan can clone 5 voices per day.
		 *     - `free` plan can clone 1 voice per day.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			/** @description Schema for cloning a voice using ElevenLabs API. */
			requestBody: {
				content: {
					"application/json": components["schemas"]["ElevenLabsCloneVoiceInput"];
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							/** @description Clone voice response. */
							result?: {
								/** @description Newly created voice ID. */
								voice_id: string;
								/** @description Newly created voice name. */
								name: string;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/elevenlabs/get_models": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get models
		 * @description Get models from ElevenLabs
		 */
		get: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							/** @description Any response from server. */
							result?: unknown;
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/elevenlabs/get_voices": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Get Voices
		 * @description Get the list of voices.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			/** @description Schema for searching voices using ElevenLabs API. */
			requestBody: {
				content: {
					"application/json": components["schemas"]["ElevenLabsSearchVoiceInput"];
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							/** @description Voice search response. */
							result?: {
								/** @description Whether there are more results. */
								has_more: boolean;
								/** @description Voices. */
								voices: components["schemas"]["ElevenLabsVoice"][];
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/elevenlabs/inference_voice": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Inference Voice
		 * @description Convert voice to another voice.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			/** @description Voice inference payload supporting JSON and multipart/form-data submissions. */
			requestBody: {
				content: {
					"multipart/form-data": components["schemas"]["ElevenLabsInferenceVoiceInput"];
					"application/json": components["schemas"]["ElevenLabsInferenceVoiceInput"];
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: components["schemas"]["ElevenLabsInferenceOutput"];
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/elevenlabs/inference_text": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Inference Text
		 * @description Convert text to speech.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			/** @description Schema for ElevenLabs text inference requests. */
			requestBody: {
				content: {
					"application/json": components["schemas"]["ElevenLabsInferenceTextInput"];
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: components["schemas"]["ElevenLabsInferenceOutput"];
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/gpt/chat": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Chat
		 * @description Chat with the GPT model
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			/** @description Chat completion request body. */
			requestBody: {
				content: {
					"application/json": components["schemas"]["GPTOpenAIChatCompletionRequest"];
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							/** @description Chat response payload. */
							result?:
								| {
										/** @description The model used to generate the response. */
										model: string;
										/**
										 * Model Message
										 * @description The message generated by the model.
										 */
										message: {
											/**
											 * @description The role of the message author.
											 * @example assistant
											 */
											role: string;
											/**
											 * @description The content of the message.
											 * @example The capital of France is Paris.
											 */
											content: string;
											function_call?: {
												/** @description The arguments to pass to the function, as a JSON string. */
												arguments?: string;
												/**
												 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
												 * @example foo_bar
												 */
												name: string;
											} | null;
											tool_calls?: {
												/** @description The ID of the tool call. */
												id?: string;
												/**
												 * @description The type of the tool call.
												 * @enum {string}
												 */
												type: "function";
												/**
												 * Function Call
												 * @description The function model wants to call, if any.
												 */
												function: {
													/** @description The arguments to pass to the function, as a JSON string. */
													arguments?: string;
													/**
													 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
													 * @example foo_bar
													 */
													name: string;
												};
											} | null;
											/** @description `web_search` annotations. */
											annotations?: {
												/**
												 * @description The type of the URL citation. Always `url_citation`.
												 * @enum {string}
												 */
												type: "url_citation";
												/** @description A URL citation when using web search. */
												url_citation: {
													/** @description The index of the last character of the URL citation in the message. */
													end_index: number;
													/** @description The index of the first character of the URL citation in the message. */
													start_index: number;
													/** @description The title of the URL citation. */
													title: string;
													/** @description The URL of the citation. */
													url: string;
												};
											}[];
											/** @description An array of base64 encoded images, if the model generated any. */
											images?: (string | null)[];
										};
								  }
								| components["schemas"]["GPTOpenAIChatCompletionResponse"];
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Default Response */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content?: never;
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/gpt/legacy/chat": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Chat - Legacy
		 * @description Chat with the GPT model (legacy).
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/**
						 * @description The model to use for the request. Fallback to fastest model available.
						 * @enum {string}
						 */
						model:
							| "gpt-3.5-turbo"
							| "gpt-4o-mini"
							| "gpt-4.1-mini"
							| "gpt-4.1"
							| "gpt-5-mini"
							| "gpt-5"
							| "gpt-5-codex"
							| "x-ai/grok-code-fast-1";
						messages: {
							/**
							 * @description The role of the message author.
							 * @example assistant
							 */
							role: string;
							/**
							 * @description The content of the message.
							 * @example The capital of France is Paris.
							 */
							content: string;
						}[];
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description The model used to generate the response. */
								model: string;
								message: {
									/**
									 * @description The role of the message author.
									 * @example assistant
									 */
									role: string;
									/**
									 * @description The content of the message.
									 * @example The capital of France is Paris.
									 */
									content: string;
									function_call?: {
										/** @description The arguments to pass to the function, as a JSON string. */
										arguments?: string;
										/**
										 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
										 * @example foo_bar
										 */
										name: string;
									} | null;
									/** @description An array of base64 encoded images, if the model generated any. */
									images?: (string | null)[];
								};
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/change_cloth_color": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Change Cloth Color
		 * @description **This API is used to change the color of clothes in an image.**
		 *
		 *     This is an example of how using [`cloth_segmentation`](#tag/image/POST/image/cloth_segmentation) API enpoint, and just change the color of the clothes in the image. You can use `inpaint` API to perform you-know-what.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/**
						 * Color
						 * @description Color string, such as `#FF0000`. Supports HEX, RGB, and common color names.
						 */
						color: string;
						/**
						 * Clothing Category
						 * @description The type of clothes to be changed.
						 *
						 *      - `None` No specific clothing type selected.
						 *     - `dress` Dress color change.
						 *     - `up` Top color change.
						 *     - `down` Bottom color change (pants, skirt, etc.).
						 *     - `coat` Coat color change.
						 *     - `up-down` Color change for both top and bottom.
						 *     - `jumpsuit` One-piece suit color change.
						 * @enum {string}
						 */
						category:
							| "None"
							| "dress"
							| "up"
							| "down"
							| "coat"
							| "up-down"
							| "jumpsuit";
						/**
						 * Initial Image
						 * @description The initial image to be processed.
						 */
						init_image: string;
						/**
						 * Synchronous Processing
						 * @description Whether to process the task synchronously. Defaults to false.
						 * @default false
						 */
						sync?: boolean;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * Status
								 * @description Current processing state of the task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/**
								 * Task ID
								 * @description The unique identifier for the task
								 */
								task_id: string;
								/**
								 * Generated Images
								 * @description Array of generated images.
								 */
								images: (string | string)[] | null;
								/**
								 * Metadata
								 * @description Additional task-related metadata, if any
								 */
								metadata?: Record<string, never>;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/cloth_segmentation": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Cloth Segmentation
		 * @description **Cloth Segmentation** is a service that segments the clothing in an image.
		 *
		 *     Extracts the clothing from the input image and provides a mask for the clothing area.
		 *
		 *     Best for you know-what.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/**
						 * Initial Image
						 * @description The initial image to be processed.
						 */
						init_image: string;
						/**
						 * Synchronous Processing
						 * @description Whether to process the task synchronously. Defaults to false.
						 * @default false
						 */
						sync?: boolean;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * Segmentation Images
								 * @description The Segmentation mask images urls
								 */
								images: {
									/**
									 * Label
									 * @description The label of the clothing segment.
									 * @enum {string}
									 */
									label:
										| "background"
										| "headpiece"
										| "hair"
										| "gloves"
										| "glasses"
										| "top"
										| "dress"
										| "coat"
										| "socks"
										| "pants"
										| "skin"
										| "scarf etc."
										| "skirt"
										| "face"
										| "shoes"
										| "bag"
										| "accessories"
										| "jumpsuit"
										| "mannequin_stand";
									/**
									 * URL
									 * @description The Segmentation mask image url
									 */
									url: string;
								}[];
								/**
								 * Initial Image
								 * @description The initial image to be processed.
								 */
								init_image: string;
								/**
								 * Synchronous Processing
								 * @description Whether to process the task synchronously. Defaults to false.
								 * @default false
								 */
								sync: boolean;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/different_me": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Different Me
		 * @description **Different Me** is a service based on image2image technology. It can change the style of the input image to a different style.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/**
						 * Style ID
						 * @description The style ID to be applied to the image
						 * @enum {string}
						 */
						style_id:
							| "animal_fest"
							| "old"
							| "doll"
							| "metal"
							| "8bit"
							| "city"
							| "blazing_torch"
							| "clay"
							| "realism"
							| "simulife"
							| "sketch"
							| "zombie"
							| "oil_stick"
							| "balloon"
							| "pipe_craft"
							| "crystal"
							| "felt"
							| "jade"
							| "pink_girl"
							| "vivid"
							| "eastern"
							| "mythical"
							| "pixel_game"
							| "league"
							| "lineage"
							| "happiness"
							| "manga"
							| "sweet"
							| "pixel_art"
							| "catwoman"
							| "loose"
							| "sakura"
							| "pocket"
							| "grains"
							| "graduation"
							| "oil_pastel"
							| "flora_tour"
							| "loong_year"
							| "figure"
							| "prospera"
							| "guardians"
							| "expedition"
							| "leisure"
							| "giftify"
							| "amiable"
							| "3d_cartoon"
							| "sketch_ii"
							| "collage"
							| "mini_doll"
							| "sketchresize"
							| "cartoon"
							| "fluffy"
							| "insta"
							| "local_graffiti"
							| "peking_opera"
							| "opera"
							| "torch"
							| "sport"
							| "dunk"
							| "anime25d"
							| "anime"
							| "comic_rl"
							| "manhwa"
							| "manhwa_female"
							| "manhwa_male"
							| "samyang"
							| "comic_idol"
							| "anime_ghibli"
							| "anime_shinchan"
							| "anime_chibi"
							| "powerpuff"
							| "anime_splash"
							| "anime_dream"
							| "game_lol"
							| "game_ps2"
							| "game_gta"
							| "game_sim"
							| "game_lr"
							| "game_dress_up"
							| "game_persona"
							| "game_stardew_valley"
							| "game_undawn"
							| "game_lineage"
							| "game_fantasy"
							| "k_comic"
							| "minecraft"
							| "card_game"
							| "kartun_dress_up"
							| "cyberpunk"
							| "dora";
						/**
						 * Initial Image
						 * @description The initial image to be processed.
						 */
						init_image: string;
						/**
						 * Synchronous Processing
						 * @description Whether to process the task synchronously. Defaults to false.
						 * @default false
						 */
						sync?: boolean;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * Status
								 * @description Current processing state of the task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/**
								 * Task ID
								 * @description The unique identifier for the task
								 */
								task_id: string;
								/**
								 * Generated Images
								 * @description Array of generated images.
								 */
								images: (string | string)[] | null;
								/**
								 * Metadata
								 * @description Additional task-related metadata, if any
								 */
								metadata?: Record<string, never>;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/enhance": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Enhance
		 * @description **Enhance** is a powerful image processing tool that can enhance basic images.
		 *
		 *     Allows you to improve the quality of your images.
		 *     With few options, you can easily enhance your images to make them look better.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						init_image: string;
						/** @default 2 */
						type?: 1 | 2 | 3;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description A list of processed image URLs */
								images: ((string | string)[] | null)[];
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/facial_expression": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Facial Expression
		 * @description **Facial Expression** is a feature that allows you to change the expression of a person in an image.
		 *
		 *     Best for social media profile pictures, avatars, and other images where you want to change the expression of a person.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/**
						 * Expression
						 * @description The expression to be applied to the image
						 * @enum {string}
						 */
						expression:
							| "laugh"
							| "smile"
							| "pose_ps"
							| "cool"
							| "cspv"
							| "dimples";
						/**
						 * Initial Image
						 * @description The initial image to be processed.
						 */
						init_image: string;
						/**
						 * Synchronous Processing
						 * @description Whether to process the task synchronously. Defaults to false.
						 * @default false
						 */
						sync?: boolean;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * Status
								 * @description Current processing state of the task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/**
								 * Task ID
								 * @description The unique identifier for the task
								 */
								task_id: string;
								/**
								 * Generated Images
								 * @description Array of generated images.
								 */
								images: (string | string)[] | null;
								/**
								 * Metadata
								 * @description Additional task-related metadata, if any
								 */
								metadata?: Record<string, never>;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/get_task": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Task
		 * @description **Get** the task status.
		 *
		 *     You may need to call this API if the any sync task is not completed.
		 *
		 *     **Note:** only call if status is `processing`
		 */
		get: {
			parameters: {
				query: {
					/** @description The unique identifier for the task to retrieve */
					task_id: string;
				};
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * Status
								 * @description Current processing state of the task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/**
								 * Task ID
								 * @description The unique identifier for the task
								 */
								task_id: string;
								/**
								 * Generated Images
								 * @description Array of generated images.
								 */
								images: (string | string)[] | null;
								/**
								 * Metadata
								 * @description Additional task-related metadata, if any
								 */
								metadata?: Record<string, never>;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/hair_change": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Hair Change
		 * @description **Hair Change** is a feature that allows you to change the hair of a person in an image.
		 *
		 *     Best for social media posts, profile pictures, and other personal images.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/**
						 * Hair Style ID
						 * @description Short code for the hairstyle to be applied.
						 * @enum {string}
						 */
						hair_id:
							| "straight_shoulder-length"
							| "wavy_shoulder-length"
							| "long_wavy"
							| "long_wavy_more-volume"
							| "straight_medium-length"
							| "wavy"
							| "long_straight"
							| "classic_bob"
							| "pixie_cut"
							| "long_layers"
							| "blunt_cut"
							| "beach_waves"
							| "side_swept_bangs"
							| "curly_bob"
							| "textured_bob"
							| "tousled_waves"
							| "loose_curls"
							| "shaggy_layers"
							| "feathered_bob"
							| "soft_waves"
							| "sleek_straight"
							| "voluminous_curls"
							| "blunt_bob"
							| "messy_bun"
							| "sleek_ponytail"
							| "half_up_half_down"
							| "wavy_medium-length";
						/**
						 * Initial Image
						 * @description The initial image to be processed.
						 */
						init_image: string;
						/**
						 * Synchronous Processing
						 * @description Whether to process the task synchronously. Defaults to false.
						 * @default false
						 */
						sync?: boolean;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * Status
								 * @description Current processing state of the task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/**
								 * Task ID
								 * @description The unique identifier for the task
								 */
								task_id: string;
								/**
								 * Generated Images
								 * @description Array of generated images.
								 */
								images: (string | string)[] | null;
								/**
								 * Metadata
								 * @description Additional task-related metadata, if any
								 */
								metadata?: Record<string, never>;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/restoration": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Image Restoration
		 * @description **Image Restoration**
		 *
		 *     Powerful image restoration capabilities, including upscaling and denoising.
		 *     Best for restoring old photos, removing noise, and enhancing image quality.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/**
						 * Restoration Mode
						 * @description The restoration quality level.
						 *     Options: `HD`, `UHD`, `NG_UHD`.
						 *
						 *     - `HD` High Definition mode.
						 *     - `UHD` Ultra High Definition mode.
						 *     - `NG_UHD` Next Generation Ultra High Definition mode. Recommended for high-quality restoration.
						 * @enum {string}
						 */
						restoration_mode: "HD" | "UHD" | "NG_UHD";
						/**
						 * Initial Image
						 * @description The initial image to be processed.
						 */
						init_image: string;
						/**
						 * Synchronous Processing
						 * @description Whether to process the task synchronously. Defaults to false.
						 * @default false
						 */
						sync?: boolean;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * Status
								 * @description Current processing state of the task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/**
								 * Task ID
								 * @description The unique identifier for the task
								 */
								task_id: string;
								/**
								 * Generated Images
								 * @description Array of generated images.
								 */
								images: (string | string)[] | null;
								/**
								 * Metadata
								 * @description Additional task-related metadata, if any
								 */
								metadata?: Record<string, never>;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/rembg": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Rembg
		 * @description **Rembg** is a powerful image processing tool that can remove the background from images.
		 *
		 *     It is particularly useful for e-commerce applications, where product images need to be displayed without distracting backgrounds.
		 *     This endpoint allows you to upload an image and receive a new image with the background removed. The image is processed using the PicWish API, which provides high-quality background removal capabilities.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						init_image: string;
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description A list of processed image URLs */
								images: ((string | string)[] | null)[];
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/image/remini": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Remini
		 * @description **Remini** is a powerful image processing tool that can enhance and restore images.
		 *
		 *     It uses advanced AI algorithms to improve image quality, remove noise, and restore details.
		 *
		 *     This API allows you to create tasks for image processing using Remini's capabilities.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"application/json": {
						/** @description The initial image to create the task from. */
						init_image: string;
						pipelines: components["schemas"]["ReminiPipelineSchema"];
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description Array of generated images. */
								images: (string | string)[] | null;
								/** @description The pipelines used to generate the images. */
								pipelines: {
									/**
									 * Bokeh Pipeline Configurations
									 * @description Bokeh effect configuration.
									 */
									bokeh?:
										| "background_blur_low"
										| "background_blur_medium"
										| "background_blur_high";
									/**
									 * Color Enhance Pipeline Configurations
									 * @description Color enhancement configuration.
									 */
									color_enhance?:
										| "prism-blend"
										| "prism-expert-a"
										| "prism-expert-c"
										| "muted"
										| "orange-teal"
										| "silky"
										| "lit_soft_warm"
										| "orange-teal_v2";
									/**
									 * Background Enhance Pipeline Configurations
									 * @description Background enhancement configuration.
									 */
									background_enhance?:
										| "shiba-strong-tensorrt"
										| "rhino-tensorrt"
										| "upsampler-bicubic";
									/**
									 * Face Lifting Pipeline Configurations
									 * @description Face lifting effect configuration.
									 */
									face_lifting?:
										| "pinko_bigger_dataset-style"
										| "movie-style"
										| "marzipan-style";
									/**
									 * @description Face enhancement using Remini model.
									 * @enum {string}
									 */
									face_enhance?: "remini";
								};
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/instagram/get_content": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Content
		 * @description Fetch Instagram content information
		 */
		get: {
			parameters: {
				query: {
					/** @description The URL of the Instagram media to fetch. */
					url: string;
				};
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/**
								 * @description The author of the media list, if available.
								 * @default null
								 */
								author: string | null;
								/**
								 * @description Description of the media list, if available.
								 * @default null
								 */
								description: string | null;
								/** @description List of media items. */
								contents: {
									/**
									 * Format: uri
									 * @description The URL of the media thumbnail image.
									 */
									thumbnail: string;
									/**
									 * Format: uri
									 * @description The direct URL to the media file.
									 */
									url: string;
									/** @description Indicates whether the media is a video. */
									isVideo: boolean;
								}[];
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/tiktok/get_content": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Content
		 * @description Fetch TikTok content information
		 */
		get: {
			parameters: {
				query: {
					/** @description TikTok content URL */
					url: string;
				};
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description Unique identifier (Aweme ID) for the TikTok content. */
								aweme_id: string;
								/** @description Unique identifier for the TikTok content. */
								id: string;
								/** @description Region code representing the country of origin. */
								region: string;
								/**
								 * Format: uri
								 * @description URL of the cover image for the TikTok content.
								 */
								cover: string;
								/**
								 * Format: uri
								 * @description URL of the AI-generated dynamic cover image.
								 */
								ai_dynamic_cover: string;
								/**
								 * Format: uri
								 * @description URL of the original cover image for the TikTok content.
								 */
								origin_cover: string;
								/** @description Duration of the TikTok content in seconds. */
								duration: number;
								/**
								 * Format: uri
								 * @description URL of the non-watermarked video.
								 */
								video_url: string;
								/**
								 * Format: uri
								 * @description URL of the watermarked video. May not be available for all videos.
								 */
								watermarked_video_url: string;
								/** @description Size of the video file in bytes. */
								size: number;
								/** @description Music information associated with the content. */
								music: {
									/** @description Unique identifier for the music. */
									id: string;
									/** @description Title of the music. */
									title: string;
									/**
									 * Format: uri
									 * @description URL of the music cover image.
									 */
									cover: string;
									/** @description Name of the music author. */
									author: string;
									/**
									 * Format: uri
									 * @description URL to play the music.
									 */
									play_url: string;
									/** @description Indicates whether the music is original. */
									original: boolean;
									/** @description Duration of the music in seconds. */
									duration: number;
									/** @description Name of the album the music belongs to. */
									album: string;
								};
								/** @description Author information associated with the content. */
								author: {
									/** @description Unique identifier for the author. */
									id: string;
									/** @description Unique username of the author. */
									unique_id: string;
									/** @description Nickname of the author. */
									nickname: string;
									/**
									 * Format: uri
									 * @description URL of the author's avatar image.
									 */
									avatar: string;
								};
								/**
								 * @description Array of images related to the TikTok content. If any.
								 * @default null
								 */
								images:
									| (
											| string
											| {
													[key: string]: unknown;
											  }
									  )[]
									| null;
								/** @description Number of times the content has been played. */
								play_count?: number;
								/** @description Number of likes (diggs) the content has received. */
								digg_count?: number;
								/** @description Number of comments on the TikTok content. */
								comment_count?: number;
								/** @description Number of times the content has been shared. */
								share_count?: number;
								/** @description Number of times the content has been downloaded. */
								download_count?: number;
								/** @description Number of times the content has been added to collections. */
								collect_count?: number;
								/** @description Unix timestamp representing the creation time of the content. */
								create_time?: number;
								/** @description Additional anchor data related to the content. */
								anchors?:
									| string
									| null
									| {
											[key: string]: unknown;
									  };
								/** @description Extra anchor information. */
								anchors_extras?: string;
								/** @description Indicates whether the content is an advertisement. */
								is_ad?: boolean;
								/** @description Commerce-related information for the content. */
								commerce_info?: unknown;
								/** @description Commercial video information for the content. */
								commercial_video_info?: unknown;
								/** @description Settings related to comments on the content. */
								item_comment_settings?: unknown;
								/** @description Users mentioned in the content. */
								mentioned_users?: string | unknown[] | null;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/tiktok/get_content_v2": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get Content V2
		 * @description Fetch TikTok content information
		 */
		get: {
			parameters: {
				query: {
					/** @description The URL of the TikTok content to download. */
					url: string;
				};
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description Unique identifier for the content. */
								id: string;
								/** @description Name of the content's author. */
								author: string;
								/** @description Region code of the content. */
								region: string;
								/** @description Description or caption of the content. */
								description: string;
								/**
								 * Format: uri
								 * @description URL of the AI-generated dynamic cover image.
								 */
								dynamic_cover: string;
								/**
								 * Format: uri
								 * @description URL of the cover image.
								 */
								cover: string;
								/**
								 * Format: uri
								 * @description Direct URL to download the TikTok video without watermark.
								 */
								video_url: string | null;
								/**
								 * Format: uri
								 * @description URL of the TikTok video with watermark.
								 */
								video_watermark_url: string | null;
								/**
								 * Format: uri
								 * @description URL of the background music used in the content.
								 */
								music_url: string | null;
								/** @description Array of image URLs if the content is images. */
								images_url: string[];
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/unmix/get_task": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get task
		 * @description Get task status of submitted task.
		 */
		get: {
			parameters: {
				query: {
					/** @description The submitted task id */
					task_id: string;
				};
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody?: never;
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description The ID of the submitted task. */
								task_id: string;
								/**
								 * @description The status of current task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/** @description The list of separated audio files. */
								audio_files:
									| {
											/** @description The name of the separated audio file. */
											name: string;
											/**
											 * Format: uri
											 * @description The download URL of separated audio.
											 */
											audio_url: string;
									  }[]
									| null;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	"/unmix/submit_task": {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Submit new task
		 * @description Submit a new audio unmixing task.
		 */
		post: {
			parameters: {
				query?: never;
				header?: never;
				path?: never;
				cookie?: never;
			};
			requestBody: {
				content: {
					"multipart/form-data": {
						init_audio: components["schemas"]["SharedInitAudioSchema"];
						/**
						 * @description Type of stems to separate:
						 *     - `vocals_instrumental`: Separate into vocals and instrumental.
						 *     - `voice_drums_bass_others`: Separate into voice, drums, bass, and others.
						 *     - `voice_drums_bass_others_v2`: Improved voice/drums/bass/others separation.
						 * @enum {string}
						 */
						stems?:
							| "vocals_instrumental"
							| "voice_drums_bass_others"
							| "voice_drums_bass_others_v2";
					};
					"application/json": {
						init_audio: components["schemas"]["SharedInitAudioSchema"];
						/**
						 * @description Type of stems to separate:
						 *     - `vocals_instrumental`: Separate into vocals and instrumental.
						 *     - `voice_drums_bass_others`: Separate into voice, drums, bass, and others.
						 *     - `voice_drums_bass_others_v2`: Improved voice/drums/bass/others separation.
						 * @enum {string}
						 */
						stems?:
							| "vocals_instrumental"
							| "voice_drums_bass_others"
							| "voice_drums_bass_others_v2";
					};
				};
			};
			responses: {
				/** @description Default Response */
				200: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": {
							/**
							 * @description Status of the request
							 * @default true
							 */
							status: boolean;
							/**
							 * @description Additional message
							 * @default success
							 */
							message: string;
							result?: {
								/** @description The ID of the submitted task. */
								task_id: string;
								/**
								 * @description The status of current task.
								 * @enum {string}
								 */
								status: "processing" | "completed" | "error";
								/** @description The list of separated audio files. */
								audio_files:
									| {
											/** @description The name of the separated audio file. */
											name: string;
											/**
											 * Format: uri
											 * @description The download URL of separated audio.
											 */
											audio_url: string;
									  }[]
									| null;
							};
						};
					};
				};
				/** @description Invalid request error */
				400: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Authorization error */
				401: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
				/** @description Internal server error */
				500: {
					headers: {
						[name: string]: unknown;
					};
					content: {
						"application/json": components["schemas"]["ResponseSchema"];
					};
				};
			};
		};
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
}
export type webhooks = Record<string, never>;
export interface components {
	schemas: {
		/** Response Schema */
		ResponseSchema: {
			/**
			 * @description Status of the request
			 * @default false
			 */
			status: boolean;
			/** @description Additional message */
			message: string;
			/** @description Request result */
			result?: Record<string, never>;
		};
		/**
		 * AISong Submit Task Auto Schema
		 * @description Auto generation mode allows the system to create music based on the provided prompt with minimal user input.
		 */
		AISongSubmitTaskAuto: {
			/**
			 * @description The action mode, must be `auto` (enum property replaced by openapi-typescript)
			 * @enum {string}
			 */
			mode: "auto";
			/**
			 * @description Model used for generation.
			 * @enum {string}
			 */
			model: "v3.0" | "v3.5" | "v4.0" | "v4.5" | "v4.5-plus";
			/** @description The prompt parameter is used to control the melody, tune, style, and so on of the entire song. */
			prompt: string;
			/** @description Whether to generate instrumental music. */
			instrumental?: boolean;
			/**
			 * @description Control the gender of the singer.
			 * @enum {string}
			 */
			gender?: "male" | "female";
		};
		/**
		 * AISong Submit Task Custom Schema
		 * @description Custom generation allows for more detailed control over the song creation process.
		 */
		AISongSubmitTaskCustom: {
			/**
			 * @description Model used for generation.
			 * @enum {string}
			 */
			model: "v3.0" | "v3.5" | "v4.0" | "v4.5" | "v4.5-plus";
			/** @description Whether to generate instrumental music. */
			instrumental?: boolean;
			/**
			 * @description Control the gender of the singer.
			 * @enum {string}
			 */
			gender?: "male" | "female";
			/**
			 * @description The action mode, must be `custom` (enum property replaced by openapi-typescript)
			 * @enum {string}
			 */
			mode: "custom";
			/** @description The prompt parameter is used to control the melody, tune, style, and so on of the entire song. */
			prompt?: string;
			/** @description The lyrics parameter controls what the song is about, If this field is set to None, then pure music will be generated. */
			lyrics?: string;
			/** @description Create a title for the song you're writing. */
			title?: string;
		};
		/**
		 * ElevenLabs Clone Voice Input Schema
		 * @description Schema for cloning a voice using ElevenLabs API.
		 */
		ElevenLabsCloneVoiceInput: {
			/** @description Audio URLs (mp3, wav, ogg, opus, flac, m4a). */
			audio_urls: string[];
			/** @description Name of the new voice. */
			name: string;
			/** @description If true, remove background noise; may reduce quality if none exists. */
			remove_background_noise?: boolean;
			server_id: components["schemas"]["ElevenLabsServerId"];
		};
		/**
		 * ElevenLabs Server ID Schema
		 * @description Valid ElevenLabs server IDs: lovita, rose, frieren.
		 * @enum {string}
		 */
		ElevenLabsServerId: "lovita" | "rose" | "frieren";
		/**
		 * ElevenLabs Search Voice Input Schema
		 * @description Schema for searching voices using ElevenLabs API.
		 */
		ElevenLabsSearchVoiceInput: {
			/**
			 * @description Filter by category.
			 * @enum {string}
			 */
			category?: "professional" | "premade" | "cloned" | "generated";
			/** @description Search term (name, category, labels). */
			query?: string;
			/** @description Page number. */
			page?: number;
			/** @description Voices per page (default 10, max 100). */
			page_size?: number;
			server_id: components["schemas"]["ElevenLabsServerId"];
		};
		/**
		 * ElevenLabs Inference Voice Input Schema
		 * @description Voice inference payload supporting JSON and multipart/form-data submissions.
		 */
		ElevenLabsInferenceVoiceInput: {
			server_id: components["schemas"]["ElevenLabsServerId"];
			/** @description Voice ID. Example: 2vhwPPmYOBQ79F4vkznp */
			voice_id: string;
			/** @description If specified, generation is deterministic (0..4294967295). */
			seed?: number;
			/** @description Output format of the generated audio (e.g. mp3_44100_128, wav_44100). */
			output_format?: string;
			/**
			 * @description Supported STS models.
			 * @enum {string}
			 */
			model_id?: "eleven_english_sts_v2" | "eleven_multilingual_sts_v2";
			/** @description Use audio isolation to remove background noise. */
			remove_background_noise?: boolean;
			/**
			 * @description For pcm_s16le_16: 16-bit PCM, 16kHz mono, little-endian. Lower latency.
			 * @enum {string}
			 */
			file_format?: "pcm_s16le_16" | "other";
			init_audio: components["schemas"]["SharedInitAudioSchema"];
			voice_settings?:
				| components["schemas"]["ElevenLabsVoiceSetting"]
				| string;
		};
		/**
		 * Initial Audio Schema
		 * @description Schema for initial audio input, either as a remote URL or a file upload.
		 */
		SharedInitAudioSchema: string | string;
		/**
		 * ElevenLabs Voice Setting Schema
		 * @description Advanced settings for voice generation.
		 */
		ElevenLabsVoiceSetting: {
			/** @description Lower = broader emotional range. Higher = more monotone. */
			stability?: number;
			/** @description How closely to adhere to the original voice. */
			similarity_boost?: number;
			/** @description Amplifies the style of the original speaker (may increase latency). */
			style?: number;
			/** @description Boost similarity to the original speaker (slightly higher latency). */
			use_speaker_boost?: boolean;
			/** @description 0.7-1.2 (1.0 default). Lower = slower; higher = faster. */
			speed?: number;
		};
		/**
		 * ElevenLabs Inference Text Input Schema
		 * @description Schema for ElevenLabs text inference requests.
		 */
		ElevenLabsInferenceTextInput: {
			server_id: components["schemas"]["ElevenLabsServerId"];
			/** @description Model to use. */
			model_id?: string;
			/** @description Voice ID. Example: 2vhwPPmYOBQ79F4vkznp */
			voice_id: string;
			/** @description If specified, generation is deterministic (0..4294967295). */
			seed?: number;
			/** @description Output format of the generated audio (e.g. mp3_44100_128, wav_44100). */
			output_format?: string;
			voice_settings?: components["schemas"]["ElevenLabsVoiceSetting"];
			/** @description Text to convert to speech. */
			text: string;
			/** @description ISO 639-1 language code. Only Turbo v2.5 / Flash v2.5 support this. */
			language_code?: string;
			/** @description Text preceding the current request; helps continuity. */
			previous_text?: string;
			/** @description Text following the current request; helps continuity. */
			next_text?: string;
			/**
			 * @description Controls text normalization. Cannot be 'on' for eleven_turbo_v2_5 / eleven_flash_v2_5.
			 * @enum {string}
			 */
			apply_text_normalization?: "auto" | "on" | "off";
		};
		/**
		 * Chat Completion Request Body
		 * @description Chat completion request body.
		 * @example {
		 *       "model": "gpt-4.1-mini",
		 *       "messages": [
		 *         {
		 *           "role": "user",
		 *           "content": "What is the capital of France?"
		 *         }
		 *       ]
		 *     }
		 */
		GPTOpenAIChatCompletionRequest: {
			/**
			 * @description Whether to return the full response or just the message.
			 *
			 *     **Note:** if `full_response` is set to `true`, the response will include the full response object, any internal functions (i.e image generator) will not be executed.
			 * @default false
			 */
			full_response: boolean;
			/**
			 * @description The model to use for the request. Fallback to fastest model available.
			 * @enum {string}
			 */
			model:
				| "gpt-3.5-turbo"
				| "gpt-4o-mini"
				| "gpt-4.1-mini"
				| "gpt-4.1"
				| "gpt-5-mini"
				| "gpt-5"
				| "gpt-5-codex"
				| "x-ai/grok-code-fast-1";
			/** @description The list of messages comprising the conversation. */
			messages: components["schemas"]["GPTOpenAIRequestMessages"][];
			/** @description Controls the randomness of the model's output. Lower values make the output more deterministic, while higher values make it more random. */
			temperature?: number;
			/** @description Deprecated in favor of tools. A list of functions the model may generate JSON inputs for. */
			functions?: {
				/**
				 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
				 * @example foo_bar
				 */
				name: string;
				/** @description A description of what the function does, used by the model to choose when and how to call the function. */
				description?: string;
				/** @description The parameters the functions accepts, described as a JSON Schema object. See the guide for examples, and the JSON Schema reference for documentation about the format. */
				parameters?: {
					[key: string]: unknown;
				};
			}[];
			/**
			 * @description Controls which (if any) function is called by the model. `auto` lets the model decide, `none` disables function calling.
			 * @enum {string}
			 */
			function_call?: "auto" | "none";
			/** @description An object specifying the format that the model must output. */
			response_format?:
				| {
						/**
						 * @description Specifies the format that the model must output.
						 * @enum {string}
						 */
						type: "text" | "json_object";
				  }
				| {
						/**
						 * @description JSON Schema format, used to specify the format of the response.
						 * @enum {string}
						 */
						type: "json_schema";
						/** @description JSON Schema format definition. */
						schema: {
							/**
							 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
							 * @example foo_bar
							 */
							name: string;
							/** @description A description of what the function does, used by the model to choose when and how to call the function. */
							description?: string;
							/** @description The schema for the response format, described as a JSON Schema object. */
							schema?: {
								[key: string]: unknown;
							};
							/** @description Whether to enable strict schema adherence when generating the output. */
							strict?: boolean;
						};
				  };
			/** @description If set to `true`, the model response data will be streamed to the client as it is generated using server-sent events. */
			stream?: boolean;
			/**
			 * @description `none` means the model will not call any tool. `auto` lets the model decide between generating a message or calling one or more tools. `required` means the model must call one or more tools.
			 * @enum {string}
			 */
			tool_choice?: "none" | "auto" | "required";
			/** @description A list of tools the model may call. */
			tools?: {
				/**
				 * @description The type of the tool. Currently, only `function` is supported.
				 * @default function
				 * @enum {string}
				 */
				type: "function";
				function: {
					/**
					 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
					 * @example foo_bar
					 */
					name: string;
					/** @description A description of what the function does, used by the model to choose when and how to call the function. */
					description?: string;
					/** @description The parameters the functions accepts, described as a JSON Schema object. See the guide for examples, and the JSON Schema reference for documentation about the format. */
					parameters?: {
						[key: string]: unknown;
					};
					/** @description Whether to enable `strict` schema adherence when generating the function call. If set to `true`, the model will follow the exact schema defined in the parameters field. */
					strict?: boolean;
				};
			}[];
			/** @description Options for the web search tool. */
			web_search_options?: {
				/**
				 * @description High level guidance for the amount of context window space to use for the search.
				 * @enum {string}
				 */
				search_context_size?: "low" | "medium" | "high";
				user_location?: null | {
					/**
					 * @description The type of location approximation. Always `approximate`.
					 * @enum {string}
					 */
					type: "approximate";
					/** @description Approximate location parameters for the search. */
					approximate: {
						/** @description Free text input for the city of the user, e.g. `San Francisco`. */
						city?: string;
						/** @description The two-letter ISO country code of the user, e.g. `US`. */
						country?: string;
						/** @description Free text input for the region of the user, e.g. `CA` or `California`. */
						region?: string;
						/** @description The IANA timezone of the user, e.g. `America/Los_Angeles`. */
						timezone?: string;
					};
				};
			};
		};
		/**
		 * Request Messages Schema
		 * @description Schema for messages sent in a chat request.
		 */
		GPTOpenAIRequestMessages:
			| {
					/**
					 * @description The role of the messages author, in this case `assistant`.
					 * @enum {string}
					 */
					role: "assistant";
					/**
					 * Assistant Content
					 * @description Assistant content
					 */
					content:
						| string
						| (
								| {
										/** @description The text content */
										text: string;
										/**
										 * @description The content type
										 * @enum {string}
										 */
										type: "text";
								  }
								| {
										/** @description The refusal message generated by the model. */
										refusal: string;
										/** @description The type of the message. */
										type: string;
								  }
						  )[];
					/** @description An optional name for the participant. Provides the model information to differentiate between participants of the same role. */
					name?: string;
			  }
			| {
					/**
					 * @description The role of the messages author, in this case `user`.
					 * @example user
					 * @enum {string}
					 */
					role: "user";
					/**
					 * User Content
					 * @description User content
					 */
					content:
						| string
						| (
								| {
										/** @description The text content */
										text: string;
										/**
										 * @description The content type
										 * @enum {string}
										 */
										type: "text";
								  }
								| {
										/** @description Image content, used when passing the image to the model. */
										image_url: {
											/** @description Absolute URL of the image or base64 encoded image data. */
											url: string;
											/** @description Specifies the detail level of the image. Learn more in the Vision guide. */
											details?: string;
										};
										/**
										 * @description The content type. Always `image_url`.
										 * @enum {string}
										 */
										type: "image_url";
								  }
								| {
										/** @description Audio content, used when passing the audio to the model. */
										input_audio: {
											/** @description Base64 encoded audio data. */
											data: string;
											/**
											 * @description The format of the encoded audio data. Currently supports `wav` and `mp3`.
											 * @enum {string}
											 */
											format: "wav" | "mp3";
										};
										/**
										 * @description The type of the content part. Always `input_audio`.
										 * @enum {string}
										 */
										type: "input_audio";
								  }
								| {
										/** @description File content, used when passing the file to the model. */
										file: {
											/** @description The base64 encoded file data, used when passing the file to the model as a string. */
											file_data: string;
											/** @description The ID of an uploaded file to use as input. */
											file_id?: string;
											/** @description The name of the file, used when passing the file to the model as a string. */
											file_name?: string;
										};
										/**
										 * @description The type of the content part. Always `file`.
										 * @enum {string}
										 */
										type: "file";
								  }
						  )[];
					/** @description An optional name for the participant. Provides the model information to differentiate between participants of the same role. */
					name?: string;
			  }
			| {
					/**
					 * @description The role of the messages author, in this case `system`.
					 * @enum {string}
					 */
					role: "system";
					/**
					 * Base Content
					 * @description The content of the message.
					 */
					content:
						| string
						| {
								/** @description The text content */
								text: string;
								/**
								 * @description The content type
								 * @enum {string}
								 */
								type: "text";
						  }[];
					/** @description An optional name for the participant. Provides the model information to differentiate between participants of the same role. */
					name?: string;
			  }
			| {
					/**
					 * @description The role of the messages author, in this case `tool`.
					 * @enum {string}
					 */
					role: "tool";
					/**
					 * Base Content
					 * @description The content of the message.
					 */
					content:
						| string
						| {
								/** @description The text content */
								text: string;
								/**
								 * @description The content type
								 * @enum {string}
								 */
								type: "text";
						  }[];
					/** @description An optional name for the participant. Provides the model information to differentiate between participants of the same role. */
					name?: string;
			  }
			| {
					/**
					 * @description The role of the function. Always `function`.
					 * @enum {string}
					 */
					role: "function";
					/** @description The name of the function to call. */
					name: string;
					/** @description The contents of the `function` message. */
					content: string;
			  }
			| {
					/**
					 * @description The role of the messages author, in this case `developer`.
					 * @enum {string}
					 */
					role: "developer";
					/**
					 * Base Content
					 * @description The content of the message.
					 */
					content:
						| string
						| {
								/** @description The text content */
								text: string;
								/**
								 * @description The content type
								 * @enum {string}
								 */
								type: "text";
						  }[];
					/** @description An optional name for the participant. Provides the model information to differentiate between participants of the same role. */
					name?: string;
			  };
		/**
		 * Remini AI Pipeline Schema
		 * @description Schema for configuring the Remini AI image pipeline.
		 */
		ReminiPipelineSchema: {
			/**
			 * Bokeh Pipeline Configurations
			 * @description Bokeh effect configuration.
			 */
			bokeh:
				| "background_blur_low"
				| "background_blur_medium"
				| "background_blur_high";
			/**
			 * Color Enhance Pipeline Configurations
			 * @description Color enhancement configuration.
			 */
			color_enhance:
				| "prism-blend"
				| "prism-expert-a"
				| "prism-expert-c"
				| "muted"
				| "orange-teal"
				| "silky"
				| "lit_soft_warm"
				| "orange-teal_v2";
			/**
			 * Background Enhance Pipeline Configurations
			 * @description Background enhancement configuration.
			 */
			background_enhance:
				| "shiba-strong-tensorrt"
				| "rhino-tensorrt"
				| "upsampler-bicubic";
			/**
			 * Face Lifting Pipeline Configurations
			 * @description Face lifting effect configuration.
			 */
			face_lifting:
				| "pinko_bigger_dataset-style"
				| "movie-style"
				| "marzipan-style";
			/**
			 * @description Face enhancement using Remini model.
			 * @enum {string}
			 */
			face_enhance: "remini";
		};
		/**
		 * AISong Task Output Schema
		 * @description Schema for a task object in AISong.
		 */
		AISongTaskOutput: {
			/**
			 * @description The status of the task
			 * @enum {string}
			 */
			status: "processing" | "completed" | "error";
			/** @description The unique identifier of the generated song */
			song_id: string;
			/** @description The title of the generated song */
			title: string;
			/**
			 * Format: uri
			 * @description The audio URL of the generated song, null if not finished
			 */
			audio_url: string | null;
			/** @description Duration of the audio in seconds */
			audio_duration: number | null;
			/**
			 * Format: uri
			 * @description The cover image URL of the song, null if not finished
			 */
			cover_url: string | null;
			/** @description The lyrics of the song, null if not finished */
			lyrics: string | null;
		};
		/**
		 * ElevenLabs Voice Schema
		 * @description Voice metadata returned from the search endpoint.
		 */
		ElevenLabsVoice: {
			/** @description ID of the voice. */
			voice_id: string;
			/** @description Name of the voice. */
			name: string;
			/** @description Category of the voice. */
			category: string;
			/**
			 * @description ISO language code.
			 * @default UNKNOWN
			 */
			language: string;
			/** @description Labels associated with the voice. */
			labels: {
				[key: string]: unknown;
			};
		};
		/**
		 * ElevenLabs Inference Output Schema
		 * @description ElevenLabs inference response payload.
		 */
		ElevenLabsInferenceOutput: {
			/** @description Audio URL. */
			audio_url: string;
		};
		/**
		 * OpenAI Full Chat Completion Response
		 * @description Full chat completion response from OpenAI-compatible models.
		 */
		GPTOpenAIChatCompletionResponse: {
			/** @description The ID of the response. */
			id: string;
			/** @description The type of the response. */
			object: string;
			/** @description The time the response was created. */
			created: number;
			/** @description The model used to generate the response. */
			model: string;
			/** @description The choices returned by the model. */
			choices: (
				| {
						/** @description The index of the choice. */
						index: number;
						/** @description The message generated by the model. */
						message:
							| {
									/**
									 * @description The role of the message author.
									 * @example assistant
									 */
									role: string;
									/**
									 * @description The content of the message.
									 * @example The capital of France is Paris.
									 */
									content: string;
									function_call?: {
										/** @description The arguments to pass to the function, as a JSON string. */
										arguments?: string;
										/**
										 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
										 * @example foo_bar
										 */
										name: string;
									} | null;
									tool_calls?: {
										/** @description The ID of the tool call. */
										id?: string;
										/**
										 * @description The type of the tool call.
										 * @enum {string}
										 */
										type: "function";
										/**
										 * Function Call
										 * @description The function model wants to call, if any.
										 */
										function: {
											/** @description The arguments to pass to the function, as a JSON string. */
											arguments?: string;
											/**
											 * @description The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
											 * @example foo_bar
											 */
											name: string;
										};
									} | null;
									/** @description `web_search` annotations. */
									annotations?: {
										/**
										 * @description The type of the URL citation. Always `url_citation`.
										 * @enum {string}
										 */
										type: "url_citation";
										/** @description A URL citation when using web search. */
										url_citation: {
											/** @description The index of the last character of the URL citation in the message. */
											end_index: number;
											/** @description The index of the first character of the URL citation in the message. */
											start_index: number;
											/** @description The title of the URL citation. */
											title: string;
											/** @description The URL of the citation. */
											url: string;
										};
									}[];
									/** @description An array of base64 encoded images, if the model generated any. */
									images?: (string | null)[];
							  }
							| {
									[key: string]: unknown;
							  };
						/** @description The reason the choice was finished. */
						finish_reason: string;
				  }
				| {
						[key: string]: unknown;
				  }
			)[];
			/** @description Token usage information. */
			usage: {
				/** @description The number of tokens used in the prompt. */
				prompt_tokens: number;
				/** @description The number of tokens used to generate the completion. */
				completion_tokens: number;
				/** @description The total number of tokens used. */
				total_tokens: number;
				/** @description The number of tokens used in the prompt, including cached and audio tokens. */
				prompt_tokens_details?: {
					cached_tokens?: number;
					audio_tokens?: number;
				};
				/** @description The number of tokens used to generate the completion, including reasoning, audio, accepted, and rejected prediction tokens. */
				completion_tokens_details?: {
					reasoning_tokens?: number;
					audio_tokens?: number;
					accepted_prediction_tokens?: number;
					rejected_prediction_tokens?: number;
				};
			};
		};
	};
	responses: never;
	parameters: never;
	requestBodies: never;
	headers: never;
	pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
