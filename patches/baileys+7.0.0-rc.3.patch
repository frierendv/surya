diff --git a/node_modules/baileys/lib/Socket/messages-send.js b/node_modules/baileys/lib/Socket/messages-send.js
index 1486449..bb9fbd8 100644
--- a/node_modules/baileys/lib/Socket/messages-send.js
+++ b/node_modules/baileys/lib/Socket/messages-send.js
@@ -9,6 +9,7 @@ import { makeKeyedMutex } from '../Utils/make-mutex.js';
 import { areJidsSameUser, getBinaryNodeChild, getBinaryNodeChildren, isJidGroup, isPnUser, jidDecode, jidEncode, jidNormalizedUser, S_WHATSAPP_NET } from '../WABinary/index.js';
 import { USyncQuery, USyncUser } from '../WAUSync/index.js';
 import { makeNewsletterSocket } from './newsletter.js';
+const ListType = proto.Message.ListMessage.ListType
 export const makeMessagesSocket = (config) => {
     const { logger, linkPreviewImageThumbnailWidth, generateHighQualityLinkPreview, options: axiosOptions, patchMessageBeforeSending, cachedGroupMetadata, enableRecentMessageCache, maxMsgRetryCount } = config;
     const sock = makeNewsletterSocket(config);
@@ -833,10 +834,59 @@ export const makeMessagesSocket = (config) => {
                 });
                 logger.debug({ jid }, 'adding device identity');
             }
+			const buttonType = getButtonType(message)
+			if(buttonType) {
+				(stanza.content).push({
+					tag: 'biz',
+					attrs: { },
+					content: [
+						{
+							tag: buttonType,
+							attrs: getButtonArgs(message),
+						}
+					]
+				})
+
+				logger.debug({ jid }, 'adding business node')
+			}
             if (additionalNodes && additionalNodes.length > 0) {
-                ;
                 stanza.content.push(...additionalNodes);
-            }
+            } else {
+				const isInteractive =
+					message?.viewOnceMessage?.message?.interactiveMessage ||
+					message?.viewOnceMessageV2?.message?.interactiveMessage ||
+					message?.viewOnceMessageV2Extension?.message?.interactiveMessage ||
+					message?.interactiveMessage;
+				const isButtons =
+					message?.viewOnceMessage?.message?.buttonsMessage ||
+					message?.viewOnceMessageV2?.message?.buttonsMessage ||
+					message?.viewOnceMessageV2Extension?.message?.buttonsMessage ||
+					message?.buttonsMessage;
+				if (
+					(isJidGroup(jid) || isPnUser(jid)) &&
+					(isInteractive || isButtons)
+				) {
+					stanza.content.push({
+						tag: "biz",
+						attrs: {},
+						content: [
+							{
+								tag: "interactive",
+								attrs: {
+									type: "native_flow",
+									v: "1",
+								},
+								content: [
+									{
+										tag: "native_flow",
+										attrs: { name: "quick_reply" },
+									},
+								],
+							},
+						],
+					});
+				}
+			}
             logger.debug({ msgId }, `sending message to ${participants.length} devices`);
             await sendNode(stanza);
             // Add message to retry cache if enabled
@@ -902,6 +952,69 @@ export const makeMessagesSocket = (config) => {
             return 'url';
         }
     };
+	const getButtonType = (message) => {
+		if(message.buttonsMessage) {
+			return 'buttons'
+		} else if(message.buttonsResponseMessage) {
+			return 'buttons_response'
+		} else if(message.interactiveResponseMessage) {
+			return 'interactive_response'
+		} else if(message.listMessage) {
+			return 'list'
+		} else if(message.listResponseMessage) {
+			return 'list_response'
+		}
+	}
+
+	const getButtonArgs = (message) => {
+		if (message.interactiveMessage?.nativeFlowMessage && message.interactiveMessage.nativeFlowMessage?.buttons?.length > 0 && message.interactiveMessage.nativeFlowMessage.buttons[0].name === 'review_and_pay') {
+         return {
+            tag: 'biz',
+            attrs: {
+               native_flow_name: 'order_details'
+            }
+         }
+      } else if(message.templateMessage) {
+			return {
+				tag: 'biz',
+				attrs: {},
+				content: [{
+					tag: 'hsm',
+					attrs: {
+						tag: 'AUTHENTICATION',
+						category: ''
+					}
+				}]
+			}
+		} else if(message.interactiveMessage?.nativeFlowMessage || message.buttonsMessage) {
+			return {
+				tag: 'biz',
+				attrs: {},
+				content: [{
+               tag: 'interactive',
+               attrs: {
+                  type: 'native_flow',
+                  v: '1'
+               },
+               content: [{
+                  tag: 'native_flow',
+                  attrs: {
+                     name: 'quick_reply'
+                  }
+               }]
+            }]
+         }
+      } else if(message.listMessage) {
+			const type = message.listMessage.listType
+			if(!type) {
+				throw new Boom('Expected list type inside message')
+			}
+
+			return { v: '2', type: ListType[type].toLowerCase() }
+		} else {
+			return {}
+		}
+	}
     const getPrivacyTokens = async (jids) => {
         const t = unixTimestampSeconds().toString();
         const result = await query({
diff --git a/node_modules/baileys/lib/Types/Message.d.ts b/node_modules/baileys/lib/Types/Message.d.ts
index 9a0e153..59bde48 100644
--- a/node_modules/baileys/lib/Types/Message.d.ts
+++ b/node_modules/baileys/lib/Types/Message.d.ts
@@ -75,9 +75,44 @@ type Contextable = {
 type ViewOnce = {
     viewOnce?: boolean;
 };
+type Buttonable = {
+    /** add buttons to the message  */
+    buttons?: proto.Message.ButtonsMessage.IButton[]
+}
+type Templatable = {
+    /** add buttons to the message (conflicts with normal buttons)*/
+    templateButtons?: proto.IHydratedTemplateButton[]
+    footer?: string
+}
+type Interactiveable = {
+    /** add buttons to the message  */
+    interactiveButtons?: proto.Message.InteractiveMessage.NativeFlowMessage.NativeFlowButton[]
+    title?: string
+    subtitle?: string
+    media?: boolean
+}
+type Shopable = {
+    shop?: proto.Message.InteractiveMessage.ShopMessage.Surface
+    id?: string
+    title?: string
+    subtitle?: string
+    media?: boolean
+}
+type Cardsable = {
+    cards?: string[]
+    subtitle?: string
+}
 type Editable = {
     edit?: WAMessageKey;
 };
+type Listable = {
+    /** Sections of the List */
+    sections?: proto.Message.ListMessage.ISection[]
+    /** Title of a List Message only */
+    title?: string
+    /** Text of the bnutton on the list (required) */
+    buttonText?: string
+}
 type WithDimensions = {
     width?: number;
     height?: number;
@@ -112,14 +147,14 @@ export type AnyMediaMessageContent = (({
     image: WAMediaUpload;
     caption?: string;
     jpegThumbnail?: string;
-} & Mentionable & Contextable & WithDimensions) | ({
+} & Mentionable & Contextable & Buttonable & Templatable & Interactiveable & Shopable & Cardsable & WithDimensions) | ({
     video: WAMediaUpload;
     caption?: string;
     gifPlayback?: boolean;
     jpegThumbnail?: string;
     /** if set to true, will send as a `video note` */
     ptv?: boolean;
-} & Mentionable & Contextable & WithDimensions) | {
+} & Mentionable & Contextable & Buttonable & Templatable & Interactiveable & Shopable & Cardsable & WithDimensions) | {
     audio: WAMediaUpload;
     /** if set to true, will send as a `voice note` */
     ptt?: boolean;
@@ -133,7 +168,7 @@ export type AnyMediaMessageContent = (({
     mimetype: string;
     fileName?: string;
     caption?: string;
-} & Contextable)) & {
+} & Contextable & Buttonable & Templatable & Interactiveable & Shopable & Cardsable & WithDimensions)) & {
     mimetype?: string;
 } & Editable;
 export type ButtonReplyInfo = {
@@ -154,11 +189,11 @@ export type WASendableProduct = Omit<proto.Message.ProductMessage.IProductSnapsh
 export type AnyRegularMessageContent = (({
     text: string;
     linkPreview?: WAUrlInfo | null;
-} & Mentionable & Contextable & Editable) | AnyMediaMessageContent | {
+} & Mentionable & Contextable & Buttonable & Templatable & Editable) | AnyMediaMessageContent | {
     event: EventMessageOptions;
 } | ({
     poll: PollMessageOptions;
-} & Mentionable & Contextable & Editable) | {
+} & Mentionable & Contextable & Buttonable & Templatable & Editable) | {
     contacts: {
         displayName?: string;
         contacts: proto.Message.IContactMessage[];
diff --git a/node_modules/baileys/lib/Utils/messages.js b/node_modules/baileys/lib/Utils/messages.js
index cf55977..152ed0d 100644
--- a/node_modules/baileys/lib/Utils/messages.js
+++ b/node_modules/baileys/lib/Utils/messages.js
@@ -25,6 +25,7 @@ const MessageTypeProto = {
     sticker: WAProto.Message.StickerMessage,
     document: WAProto.Message.DocumentMessage
 };
+const ButtonType = proto.Message.ButtonsMessage.HeaderType
 /**
  * Uses a regex to test whether the string contains a URL, and returns the URL if it does.
  * @param text eg. hello https://google.com
@@ -457,6 +458,69 @@ export const generateWAMessageContent = async (message, options) => {
     else {
         m = await prepareWAMessageMedia(message, options);
     }
+	if('buttons' in message && !!message.buttons) {
+		const buttonsMessage = {
+			buttons: message.buttons.map(b => ({ ...b, type: proto.Message.ButtonsMessage.Button.Type.RESPONSE }))
+		}
+		if('text' in message) {
+			buttonsMessage.contentText = message.text
+			buttonsMessage.headerType = ButtonType.EMPTY
+		} else {
+			if('caption' in message) {
+				buttonsMessage.contentText = message.caption
+			}
+
+			const type = Object.keys(m)[0].replace('Message', '').toUpperCase()
+			buttonsMessage.headerType = ButtonType[type]
+
+			Object.assign(buttonsMessage, m)
+		}
+
+		if('footer' in message && !!message.footer) {
+			buttonsMessage.footerText = message.footer
+		}
+
+		m = { buttonsMessage }
+	} else if('templateButtons' in message && !!message.templateButtons) {
+		const msg = {
+			hydratedButtons: message.templateButtons
+		}
+
+		if('text' in message) {
+			msg.hydratedContentText = message.text
+		} else {
+
+			if('caption' in message) {
+				msg.hydratedContentText = message.caption
+			}
+
+			Object.assign(msg, m)
+		}
+
+		if('footer' in message && !!message.footer) {
+			msg.hydratedFooterText = message.footer
+		}
+
+		m = {
+			templateMessage: {
+				fourRowTemplate: msg,
+				hydratedTemplate: msg
+			}
+		}
+	}
+
+	if('sections' in message && !!message.sections) {
+		const listMessage = {
+			sections: message.sections,
+			buttonText: message.buttonText,
+			title: message.title,
+			footerText: message.footer,
+			description: message.text,
+			listType: proto.Message.ListMessage.ListType.SINGLE_SELECT
+		}
+
+		m = { listMessage }
+	}
     if ('viewOnce' in message && !!message.viewOnce) {
         m = { viewOnceMessage: { message: m } };
     }
